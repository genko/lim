using System;
using System.Collections.Generic;
using System.Text;

namespace lim
{
    public static class LimBootstrap
    {
        public static string bootstrap = "\r\ntrue setSlot(\"and\", Object getSlot(\"evalArg\"))\r\nfalse setSlot(\"and\", false)\r\n\r\nnil setSlot(\"ifNil\", Object getSlot(\"evalArgAndReturnSelf\"))\r\nObject setSlot(\"ifNil\", Object getSlot(\"thisContext\"))\r\n\r\nnil setSlot(\"ifNilEval\", Object getSlot(\"evalArg\"))\r\nObject setSlot(\"ifNilEval\", Object getSlot(\"thisContext\"))\r\n      \r\nMessage do (\r\n\r\n\tsetSlot(\"isRightOperator\", method (\r\n\t\targuments size == (0) and (OperatorTable rightOperators contains(name))\r\n\t))\r\n\r\n\tsetSlot(\"isLeftOperator\", method (OperatorTable leftOperators contains(name)))\r\n\r\n\tsetSlot(\"operatorPrecedence\", method (\r\n\t\tif (arguments size == (0), OperatorTable operatorPrecedence(name), nil)\r\n\t))\r\n\r\n\tsetSlot(\"OperatorTable\",\r\n\t\tMap clone do(\r\n\t\t\tsetSlot(\"maxPrecedence\", nil)\r\n    \t\tsetSlot(\"contains\", getSlot(\"hasKey\"))\r\n    \t\tsetSlot(\"operatorPrecedence\", method(name,\r\n\t\t\t\trightOperators at(name) ifNilEval(leftOperators at(name))\r\n\t\t\t))\r\n\t\t\tsetSlot(\"leftOperators\",\r\n\t\t\t\tthisContext clone do(\r\n\t\t\t\t\tatPut(\":=\", 0)\r\n\t\t\t\t\tatPut(\"=\", 0)\r\n\t\t\t\t\tupdateSlot(\"maxPrecedence\", 0)\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\tsetSlot(\"rightOperators\",\r\n\t\t\t\tthisContext clone do(\r\n\t\t\t\t\tatPut(\"@\", 0) \r\n\t\t\t\t\tatPut(\"'\", 0) atPut(\".\", 0)\r\n\t\t\t\t\tatPut(\"?\", 0) atPut(\"(\", 0) atPut(\")\", 0) atPut(\":\", 0)\r\n\t\t\t\t\tatPut(\"**\", 1)\r\n\t\t\t\t\tatPut(\"++\", 2) atPut(\"--\", 2)\r\n\t\t\t\t\tatPut(\"*\", 3) atPut(\"/\", 3)\tatPut(\"%\", 3)\r\n\t\t\t\t\tatPut(\"+\", 4) atPut(\"-\", 4)\r\n\t\t\t\t\tatPut(\"<<\", 5) atPut(\">>\", 5)\r\n\t\t\t\t\tatPut(\">\", 6) atPut(\"<\", 6)  atPut(\"<=\", 6) atPut(\">=\", 6)\r\n\t\t\t\t\tatPut(\"==\", 7) atPut(\"!=\", 7)\r\n\t\t\t\t\tatPut(\"&\", 8)\r\n\t\t\t\t\tatPut(\"^\", 9)\r\n\t\t\t\t\tatPut(\"|\", 10)\r\n\t\t\t\t\tatPut(\"and\", 11) atPut(\"&&\", 11)\r\n\t\t\t\t\tatPut(\"or\", 12) atPut(\"||\", 12)\r\n\t\t\t\t\tatPut(\"..\", 13)\r\n\t\t\t\t\tatPut(\"=\", 14) atPut(\"+=\", 14) atPut(\"-=\", 14) atPut(\"*=\", 14)\r\n\t\t\t\t\tatPut(\"/=\", 14) atPut(\"%=\", 14) atPut(\"&=\", 14) atPut(\"^=\", 14)\r\n\t\t\t\t\tatPut(\"|=\", 14) atPut(\"<<=\", 14) atPut(\">>=\", 14) atPut(\":=\", 14)\r\n\t\t\t\t\tatPut(\"<-\", 14) atPut(\"<->\", 14) atPut(\"->\", 14)\r\n\t\t\t\t\tatPut(\"return\", 15)\r\n\t\t\t\t\tatPut(\",\", 16)\r\n\t\t\t\t\tupdateSlot(\"maxPrecedence\", 16)\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t)\r\n\t)\r\n\r\n\tsetSlot(\"Levels\",\r\n\t\tObject clone do(\r\n\r\n\t\t\tsetSlot(\"stack\", nil)\r\n\t\t\t\r\n\t\t\tsetSlot(\"init\", method(\r\n\t\t\t\treset\r\n\t\t\t))\r\n\t\t\t\r\n\t\t\tsetSlot(\"reset\", method(\r\n\t\t\t\tupdateSlot(\"stack\", List clone with(Level clone setRootLevel))\r\n\t\t\t\tself\r\n\t\t\t))\r\n\r\n\t\t\tsetSlot(\"nextMessage\", method(\r\n\t\t\t\tsetSlot(\"i\", stack size - (1))\r\n\t\t\t\twhile(i>=(0),\r\n\t\t\t\t\tstack at(i) finish\r\n\t\t\t\t\tsetSlot(\"i\", i - (1))\r\n\t\t\t\t)\r\n\t\t\t\treset\r\n\t\t\t))\r\n\r\n\t\t\tsetSlot(\"currentLevel\", method(stack last))\r\n\r\n\t\t\tsetSlot(\"currentPrecedence\", method(currentLevel precedence))\r\n\r\n\t\t\tsetSlot(\"popDownTo\", method(targetLevel,\r\n\t\t\t\twhile (currentPrecedence <=(targetLevel) and (currentLevel isNotAttachingArgs),\r\n\t\t\t\t\tcurrentLevel finish\r\n\t\t\t\t\tstack pop\r\n\t\t\t\t)\r\n\t\t\t))\r\n\r\n\t\t\tsetSlot(\"attachToTopAndPush\", method(msg,\r\n\t\t\t\tcurrentLevel attachAndReplace(msg)\r\n\t\t\t\tstack push(Level clone setAwaitingFirstArg(msg))\r\n\t\t\t))\r\n\r\n\t\t\tsetSlot(\"attach\", method(msg, expressions,\r\n\t\t\t\tif (msg isLeftOperator,\r\n\t\t\t\t\tattachLeftOperator(msg, expressions),\r\n\t\t\t\t\tif (msg isRightOperator,\r\n\t\t\t\t\t\tattachRightOperator(msg),\r\n\t\t                currentLevel attachAndReplace(msg)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t))\r\n\r\n            setSlot(\"attachRightOperator\",method(msg,\r\n\t\t\t\tif (msg argCount > (0),\r\n\t\t\t\t\tcurrentLevel setAlreadyHasArgs(msg)\r\n\t\t\t\t\t,\r\n\t\t\t\t\tpopDownTo(msg operatorPrecedence)\r\n\t\t\t\t\tattachToTopAndPush(msg)\r\n\t\t\t\t)\r\n\t\t\t))\r\n\r\n\t\t\tsetSlot(\"attachLeftOperator\", method(msg, expressions,\r\n\t\t\t\tsetSlot(\"attaching\", currentLevel msg)\r\n\t\t\t\tattaching ifNil(\r\n\t\t\t\t\t\"compile error requires a symbol to its left\" println\r\n\t\t\t\t)\r\n                if (attaching argCount >(0),\r\n                \t\"compiler error: the symbol to left of\" println\r\n\t\t\t\t)\r\n\t\t\t\tsetSlot(\"slotName\", attaching name)\r\n\t\t\t\tsetSlot(\"quotedSlotName\", Sequence clone appendSeq(\"\\\"\") appendSeq(slotName) appendSeq(\"\\\"\"))\r\n\t\t\t\tsetSlot(\"slotNameMessage\", Message clone setName(quotedSlotName) setCachedResult(slotName))\r\n                attaching appendArg(slotNameMessage)\r\n\t\t\t\tsetSlot(\"setSlotName\",\r\n\t\t\t\t\tif (msg name ==(\":=\"), \"setSlot\", \"updateSlot\")\r\n\t\t\t\t)\r\n                attaching setName(setSlotName)\r\n\t\t\t\tcurrentLevel setAssignment\r\n\t\t\t\tif (msg argCount >(0),\r\n\t\t\t\t\tattaching appendArg(\r\n\t\t\t\t\t\tMessage clone setName(\"\") appendArg(msg argAt(0)) setNext(msg next)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t,\r\n\t\t\t\t\tmsg next ifNil(\r\n\t\t\t\t\t\t\"compile error\" println\r\n\t\t\t\t\t)\r\n\t\t\t\t\tattaching appendArg(msg next)\r\n\t\t\t\t)\r\n\t\t\t\texpressions append(msg next)\r\n\t\t\t\tattaching setNext(nil) removeCachedResult\r\n\t\t\t\tmsg setNext(nil)\r\n\t\t\t))\r\n\r\n\t\t\tsetSlot(\"Level\",\r\n\t\t\t\tObject clone do(\r\n\t\t\t\t\tsetSlot(\"maxPrecedence\", 18)\r\n\t\t\t\t\tsetSlot(\"msg\", nil)\r\n\t\t\t\t\tsetSlot(\"precedence\", nil)\r\n\t\t\t\t\tsetSlot(\"attach\", nil)\r\n\t\t\t\t\tsetSlot(\"attachBehaviourName\", nil)\r\n\t\t\t\t\tsetSlot(\"finish\", method(\r\n\t\t\t\t\t\tif (msg, msg setNext(nil))\r\n\t\t\t\t\t\tchangeAttachBehaviour(\"attachNop\")\r\n\t\t\t\t\t))\r\n\t\t\t\t\tsetSlot(\"changeAttachBehaviour\", method(name,\r\n\t\t\t\t\t\tupdateSlot(\"attachBehaviourName\", name)\r\n\t\t\t\t\t\tupdateSlot(\"attach\", self getSlot(name))\r\n\t\t\t\t\t))\r\n\t\t\t\t\tsetSlot(\"attachAttach\", method(m, msg setNext(m)))\r\n\t\t\t\t\tsetSlot(\"attachArg\", method(m, msg appendArg(m)))\r\n\t\t\t\t\tsetSlot(\"attachNew\", method(m, updateSlot(\"msg\", m)))\r\n\t\t\t\t\tsetSlot(\"attachNop\", nil)\r\n\t\t\t\t\tchangeAttachBehaviour(\"attachNop\")\r\n\t\t\t\t\tsetSlot(\"attachAndReplace\", method(m,\r\n\t\t\t\t\t\tattach(m)\r\n\t\t\t\t\t\tupdateSlot(\"msg\", m)\r\n\t\t\t\t\t\tchangeAttachBehaviour(\"attachAttach\")\r\n\t\t\t\t\t))\r\n\t\t\t\t\tsetSlot(\"setAwaitingFirstArg\", method(m,\r\n\t\t\t\t\t\tupdateSlot(\"msg\", m)\r\n\t\t\t\t\t\tself updateSlot(\"precedence\", m operatorPrecedence)\r\n\t\t\t\t\t\tchangeAttachBehaviour(\"attachArg\")\r\n\t\t\t\t\t\tself\r\n\t\t\t\t\t))\r\n\t\t\t\t\tsetSlot(\"setAlreadyHasArgs\", method(m,\r\n\t\t\t\t\t\tchangeAttachBehaviour(\"attachAttach\")\r\n\t\t\t\t\t\tupdateSlot(\"msg\", m)\r\n\t\t\t\t\t\tself\r\n\t\t\t\t\t))\r\n\t\t\t\t\tsetSlot(\"setRootLevel\", method(\r\n\t\t\t\t\t\tupdateSlot(\"precedence\", maxPrecedence)\r\n\t\t\t\t\t\tchangeAttachBehaviour(\"attachNew\")\r\n\t\t\t\t\t\tself\r\n\t\t\t\t\t))\r\n\t\t\t\t\tsetSlot(\"setAssignment\", method(changeAttachBehaviour(\"attachAttach\")))\r\n\t\t\t\t\tsetSlot(\"isNotAttachingArgs\", method(\r\n\t\t\t\t\t\tself getSlot(\"attachArg\") != (self getSlot(\"attach\"))\r\n\t\t\t\t\t))\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t)\r\n\t)\r\n\r\n\tsetSlot(\"shuffleOn\", method(\r\n\t \tMessage setSlot(\"opShuffle\", method(opShuffleIo))\r\n\t \t\t))\r\n\r\n\tsetSlot(\"shuffleOff\", method(\r\n\t\tsetSlot(\"opShuffle\", nil)\r\n\t \t\"shuffle disabled\" println\r\n\t))\r\n\r\n\tsetSlot(\"opShuffleIo\", method(\r\n\t\tsetSlot(\"me\", self)\r\n\t\tsetSlot(\"levels\", Levels clone)\r\n\t\tsetSlot(\"expressions\", List clone with(self))\r\n\t\twhile (expressions size >= (1),\r\n\t\t\tsetSlot(\"n\", expressions pop)\r\n\t\t\twhile (n,\r\n\t\t\t\tsetSlot(\"a\", n)\r\n\t\t\t\twhile (a,\r\n\t\t\t\t\tlevels attach(a, expressions)\r\n\t\t\t\t\texpressions appendSeq(a arguments)\r\n\t\t\t\t\tupdateSlot(\"a\", a next)\r\n\t\t\t\t)\r\n\t\t\t\tlevels nextMessage\r\n\t\t\t\tupdateSlot(\"n\", n next)\r\n\t\t\t)\r\n\t\t)\r\n\t\tself\r\n\t))\r\n\r\n)\r\n\r\nMessage shuffleOn\r\n\r\n";
    }
}